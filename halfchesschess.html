<html>
<head>
<!--
  TODO: 
  // online multiplayer
  better "change your mind" features
  50 move rule
  chess clock
  performance (don't redraw everything every turn)
  -->
<title> Half Chess Chess (awaiting a better name) </title>
<style type="text/css">

body {
  background-color: gray;
}

svg.ref{/*hide the referenced svgs*/
  width: 0px;
  height:0px;
  position:fixed;
}
svg#main{
  position:fixed;
  top:0px;
  left:0px;
  width: 100%;
  height: 100vh;
  border:0px;
  padding:0px;
  margin:0px;
  box-sizing:border-box;
}
.board.animate{
  transition-property: transform;
  transition-duration: 0.5s;
}
.board>g>g:where(g:nth-child(even)>g:nth-child(even), g:nth-child(odd)>g:nth-child(odd))>rect{
  fill:  hsl(30, 35%, 50%);
}
.board>g>g:where(g:nth-child(even)>g:nth-child(odd), g:nth-child(odd)>g:nth-child(even))>rect{
  fill: hsl(40, 55%, 75%);
}
text{
  font-size: 80;
  pointer-events: none;
}
#resetturn{
  position:fixed;
}
.hidden{
  display: none;
}
.dragging{
  pointer-events: none;
}
#gameover , #multiplayerSearch{
  position:absolute;
  background-color: skyblue;
  padding:20px;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%) scale(210%); /* scale around 200% together with left:50% makes text wrapping work reasonably*/
  text-align: center;
}

.board>g>g>circle{
  fill:none;
}
.board>g>g.lastmovesrc>rect{
  filter:hue-rotate(-60deg) brightness(0.7);
  /*fill: lightgreen;*/
}
.board>g>g.lastmovedst>rect{
  filter:hue-rotate(-60deg) brightness(0.7);
  /*fill: lightgreen;*/
}
.board>g>g.source>rect{
  filter:hue-rotate(20deg) brightness(1.1);
  /*fill: lightgreen;*/
}
.board>g>g.highlight>circle{
  fill: green;
}
#main table tr>td.check{
    background-color: red;
}
#main table td div{
    height: 1em;
    width: 1em;
    display: flex;
    align-items: center;
    justify-content: center;
}
#buttons{
    font-size: 1em;
    position: fixed;
    left: 50%;
    transform: translate(-50%,150%) scale(4);
}
#buttons button{
    font-size: 1em;
}
#multiplayerSearch{
    font-size: 1em;
    position: fixed;
    left: 50%; 
    transform: translate(-50%,-50%) scale(2);
    bottom:0px;
}
#gameTag{
    font-family:monospace;
}
</style>

<script>
// generally useful functions
function fromIx(s){
  if (s instanceof Array) return s;
  let [a,b] = s.split(",")
  return [+a,+b]
}
function vadd(a,b){
  return [a[0]+b[0],a[1]+b[1]]
}
function vmul(k,v){
  return [k*v[0],k*v[1]]
}


// col 0 = white, 
// Variant = [ {Pos : PieceFn} , {Pos : PieceFn}  ]
// PieceFn = () -> Piece?
// Piece = {
//     col : WHITE | BLACK
//   , char : String
//   , getMoves : (Pos, Board) -> [Pos, Piece?][]
//   , execute : (Pos,Board,[Pos,Piece]) -> undefined | true (error)
// }
// VirtPiece = {
//   , col : WHITE | BLACK
//   , isVirtual : true
//   // , creatorBoard : Board
//   , creatorPos : Pos
//   , creator : Piece     (invariant: creatorBoard[creatorPos].includes(creator))
// }
// Board = {
//     Pos : (Piece|VirtPiece)[],
//   , variant : Variant,
//   , virtuals : [Board,pos,VirtPiece][]}  // (half)board of virt piece, pos of virt piece, virt piece
// }

// Rules around virtual pieces
// After certain moves (double pawn move and castling), a piece may be captured via a square it is not currently on
// This happens because it leaves a virtual piece behind. The virtual piece tracks which piece created it
// Virtual pieces disappear the next time the piece's owner makes a move on the board which the creating piece landed on.
// They also disappear if any piece lands on their square.
//   If an opposing piece lands on a square with a virtual piece in a valid capture of the virtual piece,
//   and the creating piece is on the current board, the creating piece is captured
//   TODO: remove the condition "and the creating piece is on the current board".
//         This could cause a piece not involved in the current move to vanish, potentially chaining through a series of kings.

// In regular chess, the above should be precisely equivalent to the usual en-passant and castling through check rules
// (when combined with the rule that moves into positions that would allow the king to be captured are illegal).

// Board/Piece manipulation
const WHITE = 0
const BLACK = 1

function isEmpty(ps){
  if(!ps) return false;
  for (let p of ps){
    if(!p.isVirtual){
      return false
    }
  }
  return true
}
function isCap(board,ps,col){ // Is capturable
  if(!ps) return undefined;
  for (let p of ps){
    if(p.col!=col && !(p.isVirtual && p.creator instanceof Pawn)){ // don't allow en passant virtuals to be captured by non-pawns
      if(!p.isVirtual || board[p.creatorPos].includes(p.creator)) return p
    }
  }
}
function isCapPawn(board,ps,col){ // Is capturable by pawn
  if(!ps) return undefined;
  for (let p of ps){
    if(p.col!=col){
      if(!p.isVirtual || board[p.creatorPos].includes(p.creator)) return p
    }
  }
}
function pushIfCap(mvs,board,pos,col){
  let p = isCap(board,board[pos],col);
  if (p){
    mvs.push([pos,p])
  }
}


function addVirt(board,pos,creatorPos,creator){
  let vp = {
    col:creator.col
  , isVirtual:true
  , creatorPos:creatorPos
  , creator:creator
  }
  let dstBoard = getSubBoard(board,pos)
  getSubBoard(board,creatorPos).virtuals.push([dstBoard,pos,vp])
  dstBoard[pos].unshift(vp)
}

// Piece definitions
class Piece {
  constructor (col){
    this.creator=this
    this.col=col
    if(this.charstr)this.char=this.charstr[col]
  }
  execute(src,board,tgt){ // Return true if move wins
    if(this.isVirtual) throw new Error("trying to move a virtual piece")

    
    //for(let [b,pos,p] of virts){// remove own virtuals
    for(let virts of getVirts(board))
      for(let i=0;i<virts.length;i++){
        let [b,pos,p] = virts[i]
        if (p.col==this.col){
          let ps=b[pos]
          let ix = ps.indexOf(p)
          if (ix!=-1) ps.splice(i,1)
          virts.splice(i--,1)
        }
      }
    let srcIx = board[src].indexOf(this)
    if (srcIx===-1) throw (new Error("Trying to execute a move with a piece which is not at src"))
    this.moved=true
    let dst = board[tgt[0]]
    if(!tgt[1]){ // non-capturing
    }
    else if( !tgt[1].isVirtual){
      if (tgt[1] instanceof King){
        dst.splice(0,dst.length,this)
        board[src].splice(srcIx,1)// remove this bit if you want a king capturing piece on the other half board to remain 
        return true
      }
    }
    else{// capture virtual piece
      let creator = tgt[1].creator
      if (creator instanceof King) {
        dst.splice(0,dst.length,this)
        board[src].splice(srcIx,1)// remove this bit if you want a king capturing piece on the other half board to remain 
        return true
      }
      //let pos = tgt[1].creatorPos
      let ps = board[tgt[1].creatorPos]
      ps.splice(ps.indexOf(creator),1)
    }
    dst.splice(0,dst.length,this)
    board[src].splice(srcIx,1)
  }
}
class Pawn extends Piece{
  getMoves(pos,board){
    let mvs = []
    let [x,y] = fromIx(pos)
    let fwds = 1-2*this.col
    if (isEmpty(board[[x,y+fwds]])){
      mvs.push([[x,y+fwds], undefined])
      if (!this.moved && isEmpty(board[[x,y+2*fwds]])){
        mvs.push([[x,y+2*fwds], undefined])
      }
    }
    for(let dx of [-1,1]){
      let p = isCapPawn(board,board[[x+dx,y+fwds]], this.col) ;
      if(p){mvs.push([[x+dx,y+fwds],p ]) }
      // pushIfCap(mvs,board,[x+dx,y+fwds],this.col)
    }
    return mvs
  }
  execute(src,board,tgt){
    let r =super.execute(src,board,tgt)
    if (r) return r
    let [x,y] = fromIx(src)
    let [x2,y2] = fromIx(tgt[0])
    if (Math.abs(y2-y)==2){
      let mid = [x,(y+y2)/2]
      addVirt(board,mid,tgt[0],this)
    }
    let [,,ny,my] = getVariantBounds(board.variant)
    console
    if(tgt[0][1]==ny || tgt[0][1]==my){
      state.push([board,"promoting",[tgt[0],this]])
      // Object.setPrototypeOf(this,Queen.prototype) // WARNING: said to make everything slow
    //new Queen(this.col)
    }
  }
  promote(become){
    Object.setPrototypeOf(this,become) // WARNING: said to make everything slow
  }
}
Pawn.prototype.charstr="♙♟︎"
Pawn.prototype.letter="P"

class Leaper extends Piece{
  getMoves(pos,board){
    let mvs = []
    for (let d of this.directions){
      let dst = vadd(d,fromIx(pos))
      if(isEmpty(board[dst])){
        mvs.push([dst,isCap(board,board[dst],this.col)])
      }
      else{
        pushIfCap(mvs,board,dst,this.col)
      }
    }
    return mvs
  }
}

class Rider extends Piece{
  getMoves(pos,board){
    let mvs = []
    for (let d of this.directions){
      let dst = vadd(d,fromIx(pos))
      while(isEmpty(board[dst])){
        mvs.push([dst,isCap(board,board[dst],this.col)])
        dst = vadd(d,dst)
      }
      pushIfCap(mvs,board,dst,this.col)
    }
    return mvs
  }
}
class Queen extends Rider{}
Queen.prototype.charstr = "♕♛"
Queen.prototype.directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
Queen.prototype.letter="Q"

class Rook extends Rider{}
Rook.prototype.charstr = "♖♜"
Rook.prototype.directions = [[-1,0],[0,-1],[0,1],[1,0]]
Rook.prototype.letter="R"
class Bishop extends Rider{}
Bishop.prototype.charstr = "♗♝"
Bishop.prototype.directions = [[-1,-1],[-1,1],[1,-1],[1,1]]
Bishop.prototype.letter="B"

class Knight extends Leaper{}
Knight.prototype.charstr = "♘♞"
Knight.prototype.directions = [[-2,-1],[-2,1],[-1,-2],[-1,2], [1,-2],[1,2],[2,-1],[2,1]]
Knight.prototype.letter="N"

class King extends Leaper{
  getMoves(pos,board){
    let mvs = super.getMoves(pos,board)
    
    if (!this.moved) for(let d of [[-1,0], [1,0]]){
      let rpos = vadd(d,fromIx(pos))
      while(isEmpty(board[rpos])){
        rpos = vadd(d,rpos)
      }
      let ps = board[rpos]
      if(!ps) break;
      for(let p of ps){
        if(p instanceof Rook && p.col==this.col && !p.moved){
          let dst = vadd(d,vadd(d,fromIx(pos)))
          if(isEmpty(board[dst])) {mvs.push([dst,undefined])}
          break;
        }
      }
    }
    return mvs.filter(p=>board.variant[this.col][p[0]]) // don't allow a king to move away from its half board
  }
  execute(src,board,tgt){
    let [x,y] = fromIx(src)
    let [x2,y2] = fromIx(tgt[0])
    let mid
    if (Math.abs(x2-x)==2){
      mid = [(x+x2)/2,y]
      let rpos = mid
      let d = [(x2-x)/2,0]
      while(isEmpty(board[rpos])){
        rpos = vadd(d,rpos)
      }
      let r
      let ps = board[rpos]
      for(let p of ps){
        if(p instanceof Rook && p.col==this.col && !p.moved){
          r=p
          break
        }
      }
      if (!r) throw new Error("can't find rook when castling")
      ps.splice(ps.indexOf(r),1)
      board[mid].splice(1,board[mid].length,r)
    }
    let r = super.execute(src,board,tgt)
    if (Math.abs(x2-x)==2){
      addVirt(board,mid,tgt[0],this)
      addVirt(board,src,tgt[0],this)
    }
    return r
  }
}
King.prototype.directions = Queen.prototype.directions
King.prototype.charstr = "♔♚"
King.prototype.letter="K"

// Functions for working with combined boards
function combineBoards(sb1,sb2){ // not always white, black unknown
  handler = {
    get(target,name){
      if(name=="subBoards") return [sb1,sb2]
      //if(name=="white") return w
      //else if(name=="black") return b
      let w = sb1[name]
      let b = sb2[name]
      if(w===undefined) return b
      if(b===undefined) return w
      if(w===b) return w // useful for "variant"
      throw new Error("trying to read property defined on both subboards")
    },
    set(target,name,value){
      throw new Error("setting properties of combined board disallowed")
    }
  }
  return new Proxy({},handler)
}
function getSubBoard(board,pos){
  sbs = board.subBoards
  if (sbs===undefined) {return board}
  let [sb1,sb2]=sbs
  let w = sb1[pos]
  let b = sb2[pos]
  if(w===undefined && b!==undefined) return sb2
  if(b===undefined && w!==undefined) return sb1
  throw new Error("pos in neither board")
}
function getVirts(board){
  sbs = board.subBoards
  if (sbs===undefined) {return [board.virtuals]}
  return sbs.map(x=>x.virtuals)
}



let pieceDict = {
  P:()=>new Pawn(WHITE),
  R:()=>new Rook(WHITE),
  N:()=>new Knight(WHITE),
  B:()=>new Bishop(WHITE),
  Q:()=>new Queen(WHITE),
  K:()=>new King(WHITE),
  p:()=>new Pawn(BLACK),
  r:()=>new Rook(BLACK),
  n:()=>new Knight(BLACK),
  b:()=>new Bishop(BLACK),
  q:()=>new Queen(BLACK),
  k:()=>new King(BLACK)
}
// FEN -> Variant
function fromFEN(fen,alt){
  fen = fen.split(" ")[0]
  let rows = fen.split("/")
  let y = rows.length-1
  if (rows.length%2!=0) {
      return
  }
  grids = [{},{}]
  for(let row of rows){
    let x = 0
    for (let c of row){
      let pfn=pieceDict[c]
      if(pfn){
        grids[+(alt?((x+y)%2):(y*2>=rows.length))][[x,y]] = [pfn]
        x+=1
      }
      else{
        for(let i=0;+c>i;i++){
          grids[+(alt?((x+y)%2):(y*2>=rows.length))][[x,y]] = []
          x+=1
        }
      }
    }
    y-=1
  }
  return grids
}
chess = fromFEN("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR")
minichess = fromFEN("rbqkn/ppppp/5/5/PPPPP/RBQKN",false)

// Variant -> Board
function makeGame(variant, subgames, half){
  let r = {variant:variant, virtuals:[]}
  let halves = half===undefined ? variant : [variant[half]]
  for (let half of halves){
    for(let k of Object.keys(half)){
      let l=[]
      for(let fn of half[k]){
        let p = fn()
        if(!p.isVirtual && subgames){
          p.subBoard = makeGame(subgames[0],subgames[1],p.col )
        }
        l.push(p)
      }
      r[k]=l
    }
  }
  return r
}
// Above here, nothing should be explicitly concerned with UI

function getBounds(board){
  let mx=-Infinity
  let my=-Infinity
  let nx = Infinity
  let ny = Infinity
  let brd = mkel("g")
  brd.classList.add("board")
  for(let k of Object.keys(board)){
    if(k.includes(",")){
      let [x,y] = fromIx(k)
      if (x>mx)mx=x
      if (y>my)my=y
      if (x<nx)nx=x
      if (y<ny)ny=y
    }
  }
  return [nx,mx,ny,my]
}
function getVariantBounds(variant){
  let [nx,mx,ny,my] = getBounds(variant[WHITE])
  let [nx2,mx2,ny2,my2] = getBounds(variant[BLACK])
  return [Math.min(nx,nx2),Math.max(mx,mx2),Math.min(ny,ny2),Math.max(my,my2)]
}

function mkel(tag){
  return document.createElementNS("http://www.w3.org/2000/svg",tag)
}

function drawBoard(board,depth){
  let [nx,mx,ny,my] = getVariantBounds(board.variant)
  board.drawing = mkel("g")
  board.drawing.classList.add("board")
  let ys = my-ny+1
  let xs = mx-nx+1
  let sz = Math.min(640 / ys, 640 / xs )
  let top = (640 - ys*sz) /2
  let left = (640 - xs*sz) /2

  //let boxH = 640 / (my-ny+1)
  //let boxW = 640 / (mx-nx+1)
  for(let y=ny;y<=my;y++){
    let row=mkel("g") 
    for(let x=nx;x<=mx;x++){
      let pos = [x,y]
      let cell = mkel("g")
      if(board[pos]){
        board[pos].cell=cell
        cell.setAttribute("transform",`translate(${left + x*sz},${top + (my-y)*sz})`)

        let rect = mkel("rect")
        rect.setAttribute("width",sz)
        rect.setAttribute("height",sz)
        cell.append(rect)
        if(depth===0) addHandlers(cell,x,y,depth)

        let ps = board[pos]
        for(let p of ps){
          if (!p.isVirtual){
            let pic = mkel("use")
            pic.classList.add("piecepic")
            pic.setAttribute("href", "#"+"wb"[p.col]+p.letter)
            pic.setAttribute("width",sz)
            pic.setAttribute("height",sz)
            p.pic = mkel("g")
            p.pic.append(pic)
            if (p.subBoard){
              let scale = 1/Math.max(xs,ys)
              let sb = drawBoard(p.subBoard,depth+1)
              sb.setAttribute("transform",`scale(${scale},${scale}) translate(32,32) scale(0.9,0.9)`) // 32 = 640*(1-0.9) / 2
              p.pic.append(sb)
            }
          }
          cell.append(p.pic)
        }

        let dot = mkel("circle")
        dot.setAttribute("cx",sz/2)
        dot.setAttribute("cy",sz/2)
        dot.setAttribute("r",sz/10) // Would pick a slightly larger radius if it didn't obscure subboards
        cell.append(dot)
      }

      row.append(cell)
    }
    board.drawing.append(row)
  }
  return board.drawing
}


function drawAll(){
  main.replaceChildren(drawBoard(state[0][0],0))
  if(lastTurn)for(let mv of lastTurn)if(mv[1]!="promoting"){
    mv[0][mv[2][0]].cell.classList.add("lastmovesrc")
    mv[0][mv[3][0]].cell.classList.add("lastmovedst")
  }
}


function resetTurn(ended){
  if (!ended && state[state.length-1][1]=="promoting"){
    clk(0,0) // Promote to Queen
    return
  }
  state = [[state[0][0],"unselected"] ]
  drawAll()
}
function endTurn(){
  turn=1-turn
  resetTurn(true)
}
function gameOver(message){
  gameovermessage.innerText=message //["White","Black"][turn]+" wins!!!"
  gameover.classList.remove("hidden")
}
function executeTurn(){
  lastTurn=state
  //let nesting = state.length
  for(let i=state.length-1;i>=0;i--){
    let [gm,,[src,p],tgt] = state[i]
    if(!p.execute(src,gm,tgt)) {
      if(state[state.length-1][1]!="promoting") {endTurn()}
      else {drawPromotion(turn)}
      break
    }
    if(i==0){
      // game is over
      gameOver(["White","Black"][turn]+" wins!!!")
      //console.log()
    }
  }
}
const promotionTypes =[Queen,Rook,Bishop,Knight]
const promotions = []

for (let c in [0,1]){
  let proms = {}
  promotionTypes.map((v,x)=>{
    proms[[x,0]] = [new v(c)]
  })
  proms.variant=[proms,proms]
  promotions.push(proms)
}
function drawPromotion(col){
  main.append(drawBoard(promotions[col],state.length-1))
  for(let r in promotions[col]){
    if (r.includes(",")){
      addHandlers(promotions[col][r].cell,...fromIx(r) ,state.length-1)
    }
  }
}

pawnlog = [[3,1],[3,3],[2,4],[3,3],[2,4],[2,3],[3,3],[2,4],[1,1],[1,2],[1,4],[1,3],[3,3],[2,4],[2,0],[0,2],[2,5],[0,3],[3,3],[2,4],[0,2],[3,5],[1,3],[1,3],[1,3],[1,2],[2,5],[2,5],[2,4],[2,4],[2,4],[2,5]]
promotelog = [[3,1],[3,3],[2,4],[3,3],[2,4],[2,3],[3,3],[2,4],[1,1],[1,2],[1,4],[1,3],[3,3],[2,4],[2,0],[0,2],[2,5],[0,3],[3,3],[2,4],[0,2],[3,5],[1,3],[1,3],[1,2],[2,5],[2,5],[2,4],[2,4],[2,4],[2,5],[0,0]]

function printlog(lg) {
  if (lg===undefined) lg=log
  return "[["+lg.join("],[")+"]]" 
}
async function replaylog(log,timing=500){
  for (let xy of log){
    clk(...xy)
    await new Promise(r => setTimeout(r, timing));
  }
}

function combineBoardsAndDraw(sb1,sb2){
  //main.appendChild(sb1.drawing)
  let comb = combineBoards(sb1,sb2)
  for (let sb of [sb1,sb2]){
    let d = sb.drawing
    let tList = d.transform.baseVal
    tList.consolidate()
    let mat = d.getCTM()
    //d.getCTM()
    //m = d.getCTM()
    //console.log(d.getCTM())
    main.appendChild(sb.drawing)
    d.classList.remove("animate")

     //tList.getItem(0).setMatrix(mat.multiply(main.children[0].getCTM().inverse()))
    tList.getItem(0).setMatrix(main.children[0].getCTM().inverse().multiply(mat))
    ;d.offsetWidth;
    setTimeout(()=>{
      d.classList.add("animate")
      tList.getItem(0).setMatrix(tList.createSVGTransformFromMatrix({a:1,b:0,c:0,d:1}))
    },0)
    for (let k of Object.keys(sb)){
      if(k.includes(",")) addHandlers(sb[k].cell,...fromIx(k) ,state.length)
    }
  }
  return comb
}
let log = []
function deselect(){
  let st = state[state.length-1]
  if(st[1]!=="selected") throw Error("trying to deselect when not selected")
  let p = st[2][1]
  let gm = st[0]
  gm[st[2][0]].cell.classList.remove("source")
  for(let mv of p.getMoves(st[2][0],gm)){
    gm[mv[0]].cell.classList.remove("highlight")
  }
  st.splice(1,2,"unselected")
}
function clk(x,y){
  log.push([x,y])
  let nesting = state.length-1
  let st = state[nesting]
  console.log("click",st)
  let gm = st[0]
  let cell = gm[[x,y]].cell
  switch (st[1]){
      case "selected":
        if (cell.classList.contains("highlight")){
          let [src,p] = st[2]
          let tgt = p.getMoves(src,gm).filter(t=>t[0]==x+","+y)
          if (tgt.length!=1) throw new Error("couldn't find move")
          tgt = tgt[0]
          st.push(tgt)
          //st.splice(1,2,"subgame",st[2],tgt)
          if(nesting==maxNesting || !tgt[1]){ //execute the move(s)
            st[1]="executing"
            executeTurn()
          }
          else{//enter subgame
            st[1]="subgame"
            state.push([combineBoardsAndDraw(p.creator.subBoard,tgt[1].creator.subBoard),"unselected"])
          }
          break;
        }
        else{
          deselect()
        }
      case "unselected":
        for(let p of gm[[x,y]]){
          if(p.col == turn && !p.isVirtual){
            cell.classList.add("source")
            for(let mv of p.getMoves([x,y],gm)){
              gm[mv[0]].cell.classList.add("highlight")
            }
            st.splice(1,1,"selected",[[x,y],p])
            break;
          }
        }
        break;
      case "promoting":
        if(y!==0)throw new Error("stuff")
        st[2][1].promote(promotionTypes[x].prototype)
        st.push([[x,y],st[2][1]])
        endTurn()
        break;
    }
}

let dragging,draghome,dragref
function startDragging(p,mouse){
  dragging = p.pic
  draghome = dragging.nextElementSibling
  main.appendChild(dragging)
  dragref = dragging.getCTM()
  let w = draghome.previousElementSibling.getAttribute("width")
  dragref.e+=(w*dragref.a)/2
  console.log(w/dragref.a)
  dragref.f+=(w*dragref.d)/2
  dragging.classList.add("dragging")
  dragTo(mouse)
  //dragging.setAttribute(transform,)
}
function dragTo(mouse){
  dragging.setAttribute("transform",`translate(${(mouse.x-dragref.e)/dragref.a},${(mouse.y-dragref.f)/dragref.d})`)
}
function stopDragging(){
  if(!dragging) {return}
  draghome.parentElement.insertBefore(dragging,draghome)
  dragging.setAttribute("transform","")
  dragging.classList.remove("dragging")
  dragging=undefined
}
function addHandlers(cell,x,y,nesting){
  cell.addEventListener("click",e=>{
    if (nesting+1==state.length && state[nesting][1]=="promoting"){
      clk(x,y)
    } 
  })
  cell.addEventListener("pointerdown",e=>{
    console.log(e)
    if (nesting+1==state.length){
      if(e.button===0 && (state[nesting][1]=="unselected" || state[nesting][1]=="selected") ){
        clk(x,y)
        if(state[nesting][1]=="selected"){
          startDragging(state[nesting][2][1],e)
        }
      }
    } 
  })
  cell.addEventListener("pointerup",e=>{
    if(dragging){
      stopDragging()
      if (nesting+1==state.length){
        if(e.button===0 && state[nesting][1]=="selected") 
          clk(x,y)
      }
    }
  })
  cell.addEventListener("pointercancel",e=>{
    if(dragging){
      stopDragging()
    }
  })
}
document.addEventListener("pointermove",(e)=>{
  if(dragging){
    dragTo(e)
  }
})
</script>

  <!-- 
curl --remote-name-all https://raw.githubusercontent.com/lichess-org/lila/refs/heads/master/public/piece/cburnett/{b,w}{B,N,R,Q,K,P}.svg
python
import os 
fs = [n for n in os.listdir() if n.endswith(".svg")]
for fn in fs:
    t=open(fn).read()
    print(f'<g id="{fn[:2]}">' +t[t.find(">")+1:t.rfind("<")]+"</g>")

for fn in fs:
    t=open(fn).read()
    print(f'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="{fn[:2]}">' +t[t.find(">")+1:t.rfind("<")]+"</svg>")
-->

<!-- cburnett pieces licensed under GFDL https://www.gnu.org/licenses/fdl-1.3.html -->
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="wR"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path stroke-linecap="butt" d="M9 39h27v-3H9v3zm3-3v-4h21v4H12zm-1-22V9h4v2h5V9h5v2h5V9h4v5"/><path d="m34 14-3 3H14l-3-3"/><path stroke-linecap="butt" stroke-linejoin="miter" d="M31 17v12.5H14V17"/><path d="m31 29.5 1.5 2.5h-20l1.5-2.5"/><path fill="none" stroke-linejoin="miter" d="M11 14h23"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="bP"><path stroke="#000" stroke-linecap="round" stroke-width="1.5" d="M22.5 9a4 4 0 0 0-3.22 6.38 6.48 6.48 0 0 0-.87 10.65c-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47a6.46 6.46 0 0 0-.87-10.65A4.01 4.01 0 0 0 22.5 9z"/></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="wB"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><g fill="#fff" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.35.49-2.32.47-3-.5 1.35-1.94 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path stroke-linejoin="miter" d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="bQ"><g fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><g stroke="none"><circle cx="6" cy="12" r="2.75"/><circle cx="14" cy="9" r="2.75"/><circle cx="22.5" cy="8" r="2.75"/><circle cx="31" cy="9" r="2.75"/><circle cx="39" cy="12" r="2.75"/></g><path stroke-linecap="butt" d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z"/><path stroke-linecap="butt" d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/><path fill="none" stroke-linecap="butt" d="M11 38.5a35 35 1 0 0 23 0"/><path fill="none" stroke="#ececec" d="M11 29a35 35 1 0 1 23 0m-21.5 2.5h20m-21 3a35 35 1 0 0 22 0m-23 3a35 35 1 0 0 24 0"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="bN"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path fill="#000" d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/><path fill="#000" d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.04-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-1-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-2 2.5-3c1 0 1 3 1 3"/><path fill="#ececec" stroke="#ececec" d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.43-9.75a.5 1.5 30 1 1-.86-.5.5 1.5 30 1 1 .86.5z"/><path fill="#ececec" stroke="none" d="m24.55 10.4-.45 1.45.5.15c3.15 1 5.65 2.49 7.9 6.75S35.75 29.06 35.25 39l-.05.5h2.25l.05-.5c.5-10.06-.88-16.85-3.25-21.34-2.37-4.49-5.79-6.64-9.19-7.16l-.51-.1z"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="wN"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path fill="#fff" d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/><path fill="#fff" d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3"/><path fill="#000" d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="wP"><path fill="#fff" stroke="#000" stroke-linecap="round" stroke-width="1.5" d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="bB"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><g fill="#000" stroke-linecap="butt"><path d="M9 36c3.4-1 10.1.4 13.5-2 3.4 2.4 10.1 1 13.5 2 0 0 1.6.5 3 2-.7 1-1.6 1-3 .5-3.4-1-10.1.5-13.5-1-3.4 1.5-10.1 0-13.5 1-1.4.5-2.3.5-3-.5 1.4-2 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path stroke="#ececec" stroke-linejoin="miter" d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="bK"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path stroke-linejoin="miter" d="M22.5 11.6V6"/><path fill="#000" stroke-linecap="butt" stroke-linejoin="miter" d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/><path fill="#000" d="M11.5 37a22.3 22.3 0 0 0 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z"/><path stroke-linejoin="miter" d="M20 8h5"/><path stroke="#ececec" d="M32 29.5s8.5-4 6-9.7C34.1 14 25 18 22.5 24.6v2.1-2.1C20 18 9.9 14 7 19.9c-2.5 5.6 4.8 9 4.8 9"/><path stroke="#ececec" d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="bR"><g fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path stroke-linecap="butt" d="M9 39h27v-3H9v3zm3.5-7 1.5-2.5h17l1.5 2.5h-20zm-.5 4v-4h21v4H12z"/><path stroke-linecap="butt" stroke-linejoin="miter" d="M14 29.5v-13h17v13H14z"/><path stroke-linecap="butt" d="M14 16.5 11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z"/><path fill="none" stroke="#ececec" stroke-linejoin="miter" stroke-width="1" d="M12 35.5h21m-20-4h19m-18-2h17m-17-13h17M11 14h23"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="wQ"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zm16.5-4.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 8.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path stroke-linecap="butt" d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-14V25L7 14l2 12z"/><path stroke-linecap="butt" d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/><path fill="none" d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0"/></g></svg>
<svg class="ref" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 45" id="wK"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path stroke-linejoin="miter" d="M22.5 11.63V6M20 8h5"/><path fill="#fff" stroke-linecap="butt" stroke-linejoin="miter" d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/><path fill="#fff" d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>

</head>
<body>
<svg xmlns="http://www.w3.org/2000/svg" id="main" width="100%" height="100%" viewbox="0 0 640 640">
  <rect x="10" y="100" width="100" height="100"></rect>
</svg>
<div id="gameover" class="hidden">
  <span id="gameovermessage">white wins!!!</span><br>
  <button onclick="startGame(variants[variantNum])">restart</button>
</div>
<div id=multiplayerSearch class="hidden">
  <span id="mpmessage"></span><br>
</div>
<button id="resetturn" onclick="resetTurn()" >
  <svg width="60" height="60" viewbox="0 0 40 40">
    <line x1="5" y1="5" x2="35" y2="35" stroke="black" stroke-width="3"></line>
    <line x1="5" y1="35" x2="35" y2="5" stroke="black" stroke-width="3"></line>
  </svg>
</button>
</body>
<script>
// Global state:
let turn = WHITE
// let game = makeGame(chess)
let state;
let maxNesting = 0
let lastTurn;
document.addEventListener("keydown",(e)=>{
  if(e.key=="Escape")resetTurn()
})
// States: 
// [[Board,"unselected"]]
// [[Board,"selected",[Pos,Piece]]]
// [[Board,"subgame",[Pos,Piece],[Pos,Piece]],[Board,"unselected"]]
// [[Board,"subgame",[Pos,Piece],[Pos,Piece]],[Board,"selected",[Pos,Piece]]]
// [[Board,"subgame",[Pos,Piece],[Pos,Piece]],[Board,"executing",[Pos,Piece],[Pos,Piece]],[Board,"promoting",[Pos,Piece]]]
// [[Board,"subgame",[Pos,Piece],[Pos,Piece]],[Board,"promoting",[Pos,Piece]]]

// drawBoard(game)

function startGame(variants){
  turn = WHITE
  state = [[makeGame(variants[0],variants[1]),"unselected"]]
  maxNesting=0
  while(variants=variants[1]){
    maxNesting++
  }
  lastTurn=undefined
  drawAll()
  gameover.classList.add("hidden")
}
let variants = [[chess,[chess]], [minichess,[minichess]], [chess,[minichess]],[minichess,[chess]]]
// let baseVariant = [minichess,[minichess]]
const urlParams = new URLSearchParams(window.location.search)
//variant = 
let variantNum = urlParams.get("v")??0
if (! (variantNum in variants)) variantNum=0
startGame(variants[variantNum])
</script>
<script id="multiplayer">
tag = urlParams.get("mp")
//let preferredSize,agreedSize
let myType=0
let ws,connected
let welcomeTimeout
let alone
let moveHistory
let oldClk

if (tag){
  const server = "wss://tesseract.nfshost.com/connect/"
  const N_JOIN = 11
  const N_WELCOME = 12
  const N_CATCHUP = 13
  const N_MOVE = 14
  const N_RESET = 17
  const N_CATCHUPDONE = 18
  const N_KICK = 19


  function setWelcomeTimeout(){
    clearTimeout(welcomeTimeout)
    welcomeTimeout = setTimeout(()=>{
      if(myType==3){
        myType = Math.random()>0.5?1:2;
      }
      welcomeState=126
      if(alone){
        mpmessage.innerHTML="Waiting for opponent to arrive"
      } else{
        startMultiplayerGame(variantNum)
      }
    }, 2000)
  }
  function connect(tag){
    multiplayerSearch.classList.remove("hidden")
    mpmessage.innerText="connecting"
    
    if(connected) ws.close()
    connected=false
    ws = new WebSocket(server+tag)
    ws.onopen = (x => {
      if(x.target===ws){
        console.log("connection started")
        connected = true
        alone=true

        moveHistory = []
        myType = 3/*
        let c = params["col"]
        if(c)c=c.toLowerCase()
        if(c=="white") myType = 1
        if(c=="black") myType = 2*/
        ws.send(new Int8Array([N_JOIN,myType,variantNum]))
        welcomeState = 0
        setWelcomeTimeout()
        lastCatchup = 0
      }
      else{
        x.target.close()
      }
    })
    ws.onmessage = (x=>{
      if(!connected || x.target!==ws){
        x.target.close()
        return;
      }
      //alone = false
      console.log("received message", x.data)
      x.data.arrayBuffer().then(x=>recieveMessage(new Int8Array(x)))
    })
    ws.onclose = (x=>{
      console.log("connection closed")
      if(x.target===ws){
        connected=false
        if(MPGameRunning)gameOver("disconnected")
        else if(!multiplayerSearch.classList.contains("hidden")){
          mpmessage.innerText = "connection"
          multiplayerSearch.classList.add("hidden")
        }
      }
    })
    ws.onerror = (x=>console.log("connection error",x))
  }
  function recieveMessage(arr){
    console.log(arr)
    //return;
    switch (arr[0]) {
      case N_JOIN:
        if(myType==3){
          if(arr[1]==1 || arr[1]==2) myType&=~arr[1]
          else myType = Math.random()>0.5?1:2;
        }
        if(alone){variantNum=Math.max(arr[2],variantNum)}
        ws.send(new Uint8Array([N_WELCOME,myType,welcomeState,variantNum]))
        if (welcomeState<124) welcomeState+=2
        if(alone){
          alone=false
          startMultiplayerGame(variantNum)
          if(welcomeState<126){
            welcomeState=126
            //startMultiplayerGame(variantNum)
            clearTimeout(welcomeTimeout)
          }
        }
        break;
      case N_WELCOME:
        alone=false
        variantNum=arr[3]
        if(welcomeState<126 && (arr[2]&-2)>=(welcomeState&-2)){
          //console.log(myType)
          myType&=~arr[1]
          //console.log(myType)
          if(myType==0){
            throw new Error("incompatible colours")
            //return tryNextTag()
          }
        }
        break;
        /*
      case N_CATCHUP:
        if(welcomeState<126 && !(welcomeState&1)){
          setWelcomeTimeout()
          if(arr[1]+arr[2]*256==lastCatchup+1){
            recieveMessage(arr.slice(3))
            lastCatchup+=1
          }
        }
        break;
      case N_CATCHUPDONE:
        if(welcomeState<126) welcomeState|=1
        break;
        */
      case N_MOVE:
        if(welcomeState<126){
          if(!alone && myType!=3){
            welcomeState=126
            startMultiplayerGame(variantNum)
            clearTimeout(welcomeTimeout)
          }else{
            throw new Error("possibly another game running on the same tag")
            //tryNextTag()
            //break;
          }
        }
        let mvdat = arr.slice(1)
        if (mvdat.length%2) throw new Error("move data not a multiple of 4")
        if (mvdat.length/4 > (maxNesting+1)) throw new Error("too much move data")
        let i=0
        mvfn = function(){
          oldClk(mvdat[i*2],mvdat[i*2+1])
          i++
          if (i*2 < mvdat.length ) setTimeout(mvfn,500)
        }
        mvfn()
        break;
      case N_KICK:
        ws.close()
        break;
      case N_RESET:
        if(confirm("do you want to reset?")){
          startMultiplayerGame(variantNum)
          moveHistory=[]
        }
        break;
      default:
        console.log("incomprehensible message",arr)
    }
  }
  let oldStartGame = startGame
  startGame = function(variant){
    if(!connected) connect(tag)
    else{
      MPGameRunning = true
      multiplayerSearch.classList.add("hidden")
      oldStartGame(variant)
    }
  }
  let oldEndTurn = endTurn
  endTurn = function(){
    if(myType-1===turn){
      dat = [N_MOVE]
      for(let st of state){
        if(st[1]!=="promoting") dat.push(...st[2][0])
        dat.push(...st[3][0])
      }
      ws.send(new Uint8Array(dat))
    }
    return oldEndTurn()
  }
  // let oldExecuteTurn = executeTurn
  // executeTurn = function(){
  //   if(myType-1===turn){
  //     dat = [N_MOVE]
  //     for(let st of state){
  //       dat.push(...st[2][0])
  //       dat.push(...st[3][0])
  //     }
  //     ws.send(new Uint8Array(dat))
  //   }
  //   return oldExecuteTurn()
  //   /*
  //   if(!nosend && !hasPriority())return false;
  //   let result
  //   if (result=oldMove([di,dj],player) ){
  //     moveHistory.push(new Int8Array([N_MOVE,di,dj, (player=="l")?1:2 ]))
  //     if(ws && !nosend)ws.send(moveHistory[moveHistory.length-1])
  //     //if(result===true){connected=false;ws.close();ws=undefined}
  //     return result;
  //   }
  //   return false*/
  // }
  if(oldClk)throw new Error("oldClk being redefined")
  oldClk=clk
  clk = function(x,y){
    if(turn!==myType-1){
      return
    }
    return oldClk(x,y)
  }
  function startMultiplayerGame(N){
    MPGameRunning = true
    multiplayerSearch.classList.add("hidden")
    startGame(variants[N])
  }
  connect(tag)

}


</script>
</html>
